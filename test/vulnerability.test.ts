'use strict';

import { expect } from 'chai';
import * as sinon from 'sinon';
import { DiagnosticSeverity, Range } from 'vscode-languageserver';

import { Vulnerability } from '../src/vulnerability';
import * as config from '../src/config';

describe('Vulnerability tests', () => {
    const mockMavenRef: string =  'mockGroupId1/mockArtifact1@mockVersion';
    const mockImageRef: string =  'mockImage@sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b';
    const mockRecommendationRef: string =  'mockGroupId1/mockArtifact1@mockRecommendationVersion';
    const mockRange: Range = {
        start: {
            line: 123,
            character: 123
        },
        end: {
            line: 456,
            character: 456
        }
    };

    class MockDependencyData {
        constructor(
            public sourceId: string,
            public issuesCount: number,
            public recommendationRef: string,
            public remediationRef: string,
            public highestVulnerabilitySeverity: string
        ) {}
    }

    class MockImageData {
        constructor(
            public sourceId: string,
            public issuesCount: number,
            public recommendationRef: string,
            public highestVulnerabilitySeverity: string
        ) {}
    }

    it('should return diagnostic with vulnerabilities for single source of type Dependency', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', 'mockRemediationRef', 'HIGH')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 2
            Highest severity: HIGH
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic with vulnerabilities for single source of type Image', async () => {
        const mockImageData: MockImageData[] = [
            new MockImageData('snyk(snyk)', 2, '', 'HIGH')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockImageRef,
            mockImageData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockImage@sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 2
            Highest severity: HIGH
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic with vulnerabilities for multi source', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', 'mockRemediationRef', 'HIGH'),
            new MockDependencyData('oss(oss)', 3, '', 'mockRemediationRef', 'LOW')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 2
            Highest severity: HIGH

            oss(oss) vulnerability info:
            Known security vulnerabilities: 3
            Highest severity: LOW
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic without vulnerabilities and with recommendation for single source', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 0, mockRecommendationRef, '', 'NONE')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: mockGroupId1/mockArtifact1@mockRecommendationVersion
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic without vulnerabilities and with recommendation for multi source', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 0, mockRecommendationRef, '', 'NONE'),
            new MockDependencyData('oss(oss)', 0, mockRecommendationRef, '', 'NONE')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: mockGroupId1/mockArtifact1@mockRecommendationVersion

            oss(oss) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: mockGroupId1/mockArtifact1@mockRecommendationVersion
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic without vulnerabilities and without recommendation for single source', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 0, '', '', 'NONE')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: No Red Hat recommendations
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic without vulnerabilities for multi source where one where some sources do not have recommendations and others do', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 0, '', '', 'NONE'),
            new MockDependencyData('oss(oss)', 0, mockRecommendationRef, '', 'NONE')

        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: No Red Hat recommendations

            oss(oss) vulnerability info:
            Known security vulnerabilities: 0
            Recommendation: mockGroupId1/mockArtifact1@mockRecommendationVersion
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic where some sources have vulnerabilities and others dont', async () => {
        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', 'mockRemediationRef', 'HIGH'),
            new MockDependencyData('oss(oss)', 0, mockRecommendationRef, '', 'NONE')

        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.message.replace(/\s/g, "")).to.eql(`
            mockGroupId1/mockArtifact1@mockVersion

            snyk(snyk) vulnerability info:
            Known security vulnerabilities: 2
            Highest severity: HIGH
        `.replace(/\s/g, ""));
    });

    it('should return diagnostic with diagnostic severity set to Error', async () => {
        let globalConfig = {
            vulnerabilityAlertSeverity: 'Error'
        };
        sinon.stub(config, 'globalConfig').value(globalConfig);

        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', '', 'HIGH')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.severity).to.eql(DiagnosticSeverity.Error);
    });

    it('should return diagnostic with diagnostic severity set to Warning', async () => {
        let globalConfig = {
            vulnerabilityAlertSeverity: 'Warning'
        };
        sinon.stub(config, 'globalConfig').value(globalConfig);

        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', '', 'HIGH')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.severity).to.eql(DiagnosticSeverity.Warning);
    });

    it('should return diagnostic with diagnostic severity set to default', async () => {
        let globalConfig = {
            vulnerabilityAlertSeverity: ''
        };
        sinon.stub(config, 'globalConfig').value(globalConfig);

        const mockDependencyData: MockDependencyData[] = [
            new MockDependencyData('snyk(snyk)', 2, '', '', 'HIGH')
        ];
        let vulnerability = new Vulnerability(
            mockRange,
            mockMavenRef,
            mockDependencyData
        );

        const diagnostic = vulnerability.getDiagnostic();
        expect(diagnostic.severity).to.eql(DiagnosticSeverity.Error);
    });
});
